using Microsoft.EntityFrameworkCore;
using ProjectTutwiler.Data;
using ProjectTutwiler.Services.DataIngestion;
using ProjectTutwiler.Services.AI;

namespace ProjectTutwiler.BackgroundJobs;

public static class VulnerabilityJobs
{
    /// <summary>
    /// Scheduled job to ingest vulnerabilities from NVD and CISA KEV
    /// Runs every 12 hours
    /// </summary>
    public static async Task RunScheduledIngestionAsync(IServiceProvider serviceProvider)
    {
        using var scope = serviceProvider.CreateScope();
        var logger = scope.ServiceProvider.GetRequiredService<ILogger<IngestionOrchestrator>>();
        
        try
        {
            logger.LogInformation("=== HANGFIRE JOB: Starting scheduled vulnerability ingestion ===");
            
            var orchestrator = scope.ServiceProvider.GetRequiredService<IngestionOrchestrator>();
            
            // Ingest vulnerabilities from last 7 days
            var result = await orchestrator.RunFullIngestionAsync(nvdDaysBack: 7);
            
            logger.LogInformation(
                "=== HANGFIRE JOB: Ingestion completed - NVD: {NvdCount} vulnerabilities ({NvdNew} new), KEV: {KevCount} exploited ===",
                result.NvdResults.TotalFetched,
                result.NvdResults.NewAdded,
                result.TotalKnownExploited
            );
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "=== HANGFIRE JOB: Error during scheduled ingestion ===");
            throw; // Hangfire will mark job as failed and retry if configured
        }
    }

    /// <summary>
    /// Scheduled job to process unanalyzed vulnerabilities
    /// Runs every 30 minutes
    /// </summary>
    public static async Task ProcessUnanalyzedVulnerabilitiesAsync(IServiceProvider serviceProvider)
    {
        using var scope = serviceProvider.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
        var analysisService = scope.ServiceProvider.GetRequiredService<VulnerabilityAnalysisService>();
        var logger = scope.ServiceProvider.GetRequiredService<ILogger<VulnerabilityAnalysisService>>();
        
        try
        {
            logger.LogInformation("=== HANGFIRE JOB: Starting vulnerability analysis processing ===");
            
            // Get vulnerabilities without BioImpactScore (not analyzed yet)
            var unanalyzedVulnerabilities = await context.Vulnerabilities
                .Where(v => v.BioImpactScore == null)
                .OrderByDescending(v => v.KnownExploited) // Prioritize known exploited
                .ThenByDescending(v => v.CvssScore) // Then by severity
                .ThenBy(v => v.PublishedDate) // Then by recency
                .Take(50)
                .ToListAsync();

            if (!unanalyzedVulnerabilities.Any())
            {
                logger.LogInformation("=== HANGFIRE JOB: No unanalyzed vulnerabilities found ===");
                return;
            }

            logger.LogInformation(
                "=== HANGFIRE JOB: Found {Count} unanalyzed vulnerabilities, processing batch ===",
                unanalyzedVulnerabilities.Count
            );

            int successCount = 0;
            int errorCount = 0;

            foreach (var vulnerability in unanalyzedVulnerabilities)
            {
                try
                {
                    await analysisService.AnalyzeAndScoreVulnerabilityAsync(vulnerability.Id);
                    successCount++;
                    
                    logger.LogDebug(
                        "Successfully analyzed vulnerability {CveId} ({Success}/{Total})",
                        vulnerability.CveId,
                        successCount,
                        unanalyzedVulnerabilities.Count
                    );

                    // Small delay to avoid overwhelming Ollama API
                    await Task.Delay(1000);
                }
                catch (Exception ex)
                {
                    errorCount++;
                    logger.LogError(
                        ex,
                        "Error analyzing vulnerability {CveId} ({Errors} errors so far)",
                        vulnerability.CveId,
                        errorCount
                    );
                    // Continue processing other vulnerabilities even if one fails
                }
            }

            logger.LogInformation(
                "=== HANGFIRE JOB: Analysis processing completed - Success: {Success}, Errors: {Errors} ===",
                successCount,
                errorCount
            );
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "=== HANGFIRE JOB: Fatal error during vulnerability processing ===");
            throw;
        }
    }
}

