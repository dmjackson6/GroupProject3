using Newtonsoft.Json;
using ProjectTutwiler.Data;
using ProjectTutwiler.Models;

namespace ProjectTutwiler.Services.DataIngestion;

public class VulnerabilityIngestionService
{
    private readonly NvdApiClient _nvdApiClient;
    private readonly CisaKevClient _kevClient;
    private readonly IVulnerabilityRepository _repository;
    private readonly ILogger<VulnerabilityIngestionService> _logger;

    public VulnerabilityIngestionService(
        NvdApiClient nvdApiClient,
        CisaKevClient kevClient,
        IVulnerabilityRepository repository,
        ILogger<VulnerabilityIngestionService> logger)
    {
        _nvdApiClient = nvdApiClient;
        _kevClient = kevClient;
        _repository = repository;
        _logger = logger;
    }

    public async Task<IngestionResult> IngestFromNvdAsync(int daysBack = 7)
    {
        var result = new IngestionResult();

        try
        {
            _logger.LogInformation("Starting vulnerability ingestion from NVD for last {DaysBack} days", daysBack);

            // Fetch vulnerabilities from NVD
            var vulnerabilities = await _nvdApiClient.FetchRecentVulnerabilitiesAsync(daysBack);
            result.TotalFetched = vulnerabilities.Count;

            _logger.LogInformation("Fetched {Count} vulnerabilities from NVD. Processing...", vulnerabilities.Count);

            // Process each vulnerability with deduplication
            foreach (var vulnerability in vulnerabilities)
            {
                try
                {
                    // Check if CVE already exists
                    var exists = await _repository.ExistsAsync(vulnerability.CveId);

                    if (exists)
                    {
                        result.DuplicatesSkipped++;
                        _logger.LogDebug("Duplicate skipped: {CveId}", vulnerability.CveId);
                        continue;
                    }

                    // Add new vulnerability
                    await _repository.AddAsync(vulnerability);
                    result.NewAdded++;
                    _logger.LogInformation("Added new vulnerability: {CveId}", vulnerability.CveId);
                }
                catch (Exception ex)
                {
                    result.Errors++;
                    _logger.LogError(ex, "Error processing vulnerability {CveId}", vulnerability.CveId);
                }
            }

            result.Message = $"Ingestion completed: {result.NewAdded} new, {result.DuplicatesSkipped} duplicates, {result.Errors} errors";
            _logger.LogInformation(result.Message);

            return result;
        }
        catch (Exception ex)
        {
            result.Errors++;
            result.Message = $"Ingestion failed: {ex.Message}";
            _logger.LogError(ex, "Error during vulnerability ingestion");
            return result;
        }
    }

    public async Task<IngestionResult> IngestFromCisaKevAsync()
    {
        var result = new IngestionResult
        {
            Message = "CISA KEV Ingestion"
        };

        try
        {
            _logger.LogInformation("Starting CISA KEV ingestion");

            // Fetch KEV catalog
            var kevVulnerabilities = await _kevClient.FetchKevCatalogAsync();
            result.TotalFetched = kevVulnerabilities.Count;

            _logger.LogInformation("Fetched {Count} known exploited vulnerabilities from CISA KEV", kevVulnerabilities.Count);

            int existingUpdated = 0;

            // Process each KEV vulnerability
            foreach (var kevVuln in kevVulnerabilities)
            {
                try
                {
                    // Check if vulnerability already exists
                    var existing = await _repository.GetByCveIdAsync(kevVuln.CveID);

                    if (existing != null)
                    {
                        // Update existing vulnerability
                        existing.KnownExploited = true;
                        existing.UpdatedAt = DateTime.UtcNow;

                        // Update exploitability score if BioImpactScore exists
                        if (existing.BioImpactScore != null)
                        {
                            existing.BioImpactScore.ExploitabilityScore = 100;
                            _logger.LogInformation("Updated exploitability score to 100 for {CveId}", kevVuln.CveID);
                        }

                        await _repository.UpdateAsync(existing);
                        existingUpdated++;
                        _logger.LogInformation("Marked {CveId} as actively exploited", kevVuln.CveID);
                    }
                    else
                    {
                        // Create new vulnerability from KEV data
                        var newVulnerability = new Vulnerability
                        {
                            CveId = kevVuln.CveID,
                            SourceName = "CISA_KEV",
                            VendorName = kevVuln.VendorProject,
                            Description = kevVuln.ShortDescription,
                            KnownExploited = true,
                            AffectedProducts = JsonConvert.SerializeObject(new[] { kevVuln.Product }),
                            RawData = JsonConvert.SerializeObject(kevVuln),
                            CreatedAt = DateTime.UtcNow,
                            UpdatedAt = DateTime.UtcNow
                        };

                        // Try to parse dateAdded
                        if (DateTime.TryParse(kevVuln.DateAdded, out var dateAdded))
                        {
                            newVulnerability.PublishedDate = dateAdded;
                        }

                        await _repository.AddAsync(newVulnerability);
                        result.NewAdded++;
                        _logger.LogInformation("Added new KEV vulnerability: {CveId}", kevVuln.CveID);
                    }
                }
                catch (Exception ex)
                {
                    result.Errors++;
                    _logger.LogError(ex, "Error processing KEV vulnerability {CveId}", kevVuln.CveID);
                }
            }

            result.DuplicatesSkipped = existingUpdated; // Using DuplicatesSkipped field for "ExistingUpdated"
            result.Message = $"KEV Ingestion completed: {result.NewAdded} new, {existingUpdated} updated, {result.Errors} errors";
            _logger.LogInformation(result.Message);

            return result;
        }
        catch (Exception ex)
        {
            result.Errors++;
            result.Message = $"KEV Ingestion failed: {ex.Message}";
            _logger.LogError(ex, "Error during CISA KEV ingestion");
            return result;
        }
    }
}

